# 题目
`https://leetcode-cn.com/problems/2-keys-keyboard/`

# 题意
初始时，字符串为`A`（即1个`A`），有两种操作：
1. 复制整个当前字符串
2. 粘贴所复制的内容

求构造n个`A`的字符串最少需要几步。  


# 思路
设f(n)表示第n次复制时，字符串的长度，则:
f(n) = x1 * f(n-1)
     = x1 * x2 * f(n-2)
     = x1 * x2 * .... * f(1)

f(1) = 1

min(x1+x2+x3+...) 则是我们所求的答案。

利用以上结论，不难设计出带记忆（用于剪枝）的dfs，暴力每一个可能的xi



```cpp
class Solution {
public:
    void dfs(int cp, int cost, int n, map<int, int>& mp){
        for(int i=2*cp; i<=n; i+=cp){
            if(n%i==0){
                int cn = cost+i/cp;
                auto it = mp.find(i);
                if(it != mp.end()){ 
                    if(cn < mp[i]){
                        mp[i] = cn;
                        dfs(i, cn, n, mp);
                    }
                }
                else{
                    mp[i] = cn;
                    dfs(i, cn, n, mp);
                }
            }
        }
    }


    int minSteps(int n) {
        map<int, int> mp;
        dfs(1, 0, n, mp);
        return mp[n];
    }
};
```