# 并查集使用场景
1. 判断是否同在一个集合
    - 一条边的两个点如果在一个集合，那说明加入这条边会产生环


# golang

## 路径压缩
```go
type UnionFindSet struct {
    fa []int 
}

func Init(s *UnionFindSet, n int) {
    s.fa = make([]int, n)
    for i:=0; i<n; i++ {
        s.fa[i] = i;
    }
}

func (s *UnionFindSet) find(x int) int {
    if x == s.fa[x] {
        return x
    } else {
        s.fa[x] = s.find(s.fa[x])
        return s.fa[x] 
    }
}

func (s *UnionFindSet) union(x, y int) bool {
    px := s.find(x)
    py := s.find(y)
    if px != py {
        s.fa[px] = py
        return true
    } else {
        return false 
    }
}
```

## 按秩合并+路径压缩
```go
type UnionFindSet struct {
    fa, rank []int
}

func Init(s *UnionFindSet, n int) {
    s.fa = make([]int, n)
    s.rank = make([]int, n)
    for i:=0; i<n; i++ {
        s.fa[i] = i;
        s.rank[i] = 1;
    }
}

func (s *UnionFindSet) find(x int) int {
    if s.fa[x] == x {
        return x 
    } else {
        s.fa[x] = s.find(s.fa[x])
        return s.fa[x];
    }
}

func (s *UnionFindSet) union(x, y int) bool {
    px := s.find(x)
    py := s.find(y)
    if px != py {
        if s.rank[px] <= s.rank[py] {
            s.fa[px] = py
            if s.rank[px] == s.rank[py] {
                s.rank[py] += 1 
            }
        } else {
            s.fa[py] = px 
        }
        return true
    } else {
        return false 
    }
}
```

# cpp
```cpp

```